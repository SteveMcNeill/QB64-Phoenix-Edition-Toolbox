'$INCLUDE:'Toolbox.BI'
'Let above is only enabled to allow the auto-formatting and syntax checking to run.
'Be certain to disable if before saving or using this file.



$If INCLUDE_ALL = TRUE OR INCLUDE_MEM = TRUE OR INCLUDE_CONVERT_OFFSET = TRUE Then
    $If CONVERTOFFSET_BM = UNDEFINED Then
        $Let CONVERTOFFSET_BM = TRUE
        Function ConvertOffset&& (value As _Offset)
            $Checking:Off
            Dim m As _MEM 'Define a memblock
            m = _Mem(value) 'Point it to use value
            $If 64BIT Then
                'On 64 bit OSes, an OFFSET is 8 bytes in size.  We need an Integer64 to store it.
                Dim temp As _Integer64
            $Else
                    'However, on 32 bit OSes, an OFFSET is only 4 bytes.  We need to put it into a LONG variable first
                    dim temp as long
            $End If
            _MemGet m, m.OFFSET, temp 'Like this
            _MemFree m 'Free the memblock
            $Checking:On
            ConvertOffset = temp
        End Function
    $End If
$End If


$If INCLUDE_ALL = TRUE OR INCLUDE_MEM = TRUE OR INCLUDE_MEMSORT = TRUE Then
    $If MEMSORT_BM = UNDEFINED Then
        $Let MEMSORT_BM = TRUE
        Sub MemSort (m As _MEM)
            Dim i As _Unsigned Long
            Dim As Long DataType, i1, gap, swapped, false
            $If 64BIT Then
                Dim ES As _Integer64, EC As _Integer64
            $Else
                    DIM ES AS LONG, EC AS LONG
            $End If

            If Not m.TYPE And 65536 Then Exit Sub 'We won't work without an array
            If m.TYPE And 1024 Then DataType = 10
            If m.TYPE And 1 Then DataType = DataType + 1
            If m.TYPE And 2 Then DataType = DataType + 2
            If m.TYPE And 4 Then If m.TYPE And 128 Then DataType = DataType + 4 Else DataType = 3
            If m.TYPE And 8 Then If m.TYPE And 128 Then DataType = DataType + 8 Else DataType = 5
            If m.TYPE And 32 Then DataType = 6
            If m.TYPE And 512 Then DataType = 7

            'Convert our offset data over to something we can work with
            Dim m1 As _MEM: m1 = _MemNew(Len(ES))
            _MemPut m1, m1.OFFSET, m.ELEMENTSIZE: _MemGet m1, m1.OFFSET, ES 'Element Size
            _MemPut m1, m1.OFFSET, m.SIZE: _MemGet m1, m1.OFFSET, EC 'Element Count will temporily hold the WHOLE array size
            _MemFree m1

            EC = EC / ES - 1 'Now we take the whole element size / the size of the elements and get our actual element count.  We subtract 1 so our arrays start at 0 and not 1.
            'And work with it!
            Dim o As _Offset, o1 As _Offset, counter As _Unsigned Long

            Select Case DataType
                Case 1 'BYTE
                    Dim temp1(-128 To 127) As _Unsigned Long
                    Dim t1 As _Byte
                    i = 0
                    Do
                        _MemGet m, m.OFFSET + i, t1
                        temp1(t1) = temp1(t1) + 1
                        i = i + 1
                    Loop Until i > EC
                    i1 = -128
                    Do
                        Do Until temp1(i1) = 0
                            _MemPut m, m.OFFSET + counter, i1 As _BYTE
                            counter = counter + 1
                            temp1(i1) = temp1(i1) - 1
                            If counter > EC Then Exit Sub
                        Loop
                        i1 = i1 + 1
                    Loop Until i1 > 127
                Case 2: 'INTEGER
                    Dim temp2(-32768 To 32767) As _Unsigned Long
                    Dim t2 As Integer
                    i = 0
                    Do
                        _MemGet m, m.OFFSET + i * 2, t2
                        temp2(t2) = temp2(t2) + 1
                        i = i + 1
                    Loop Until i > EC
                    i1 = -32768
                    Do
                        Do Until temp2(i1) = 0
                            _MemPut m, m.OFFSET + counter * 2, i1 As INTEGER
                            counter = counter + 1
                            temp2(i1) = temp2(i1) - 1
                            If counter > EC Then Exit Sub
                        Loop
                        i1 = i1 + 1
                    Loop Until i1 > 32767
                Case 3 'SINGLE
                    Dim T3a As Single, T3b As Single
                    gap = EC
                    Do
                        gap = 10 * gap \ 13
                        If gap < 1 Then gap = 1
                        i = 0
                        swapped = 0
                        Do
                            o = m.OFFSET + i * 4
                            o1 = m.OFFSET + (i + gap) * 4
                            If _MemGet(m, o, Single) > _MemGet(m, o1, Single) Then
                                _MemGet m, o1, T3a
                                _MemGet m, o, T3b
                                _MemPut m, o1, T3b
                                _MemPut m, o, T3a
                                swapped = -1
                            End If
                            i = i + 1
                        Loop Until i + gap > EC
                    Loop Until gap = 1 And swapped = 0
                Case 4 'LONG
                    Dim T4a As Long, T4b As Long
                    gap = EC
                    Do
                        gap = 10 * gap \ 13
                        If gap < 1 Then gap = 1
                        i = 0
                        swapped = 0
                        Do
                            o = m.OFFSET + i * 4
                            o1 = m.OFFSET + (i + gap) * 4
                            If _MemGet(m, o, Long) > _MemGet(m, o1, Long) Then
                                _MemGet m, o1, T4a
                                _MemGet m, o, T4b
                                _MemPut m, o1, T4b
                                _MemPut m, o, T4a
                                swapped = -1
                            End If
                            i = i + 1
                        Loop Until i + gap > EC
                    Loop Until gap = 1 And swapped = 0
                Case 5 'DOUBLE
                    Dim T5a As Double, T5b As Double
                    gap = EC
                    Do
                        gap = 10 * gap \ 13
                        If gap < 1 Then gap = 1
                        i = 0
                        swapped = 0
                        Do
                            o = m.OFFSET + i * 8
                            o1 = m.OFFSET + (i + gap) * 8
                            If _MemGet(m, o, Double) > _MemGet(m, o1, Double) Then
                                _MemGet m, o1, T5a
                                _MemGet m, o, T5b
                                _MemPut m, o1, T5b
                                _MemPut m, o, T5a
                                swapped = -1
                            End If
                            i = i + 1
                        Loop Until i + gap > EC
                    Loop Until gap = 1 And swapped = 0
                Case 6 ' _FLOAT
                    Dim T6a As _Float, T6b As _Float
                    gap = EC
                    Do
                        gap = 10 * gap \ 13
                        If gap < 1 Then gap = 1
                        i = 0
                        swapped = 0
                        Do
                            o = m.OFFSET + i * 32
                            o1 = m.OFFSET + (i + gap) * 32
                            If _MemGet(m, o, _Float) > _MemGet(m, o1, _Float) Then
                                _MemGet m, o1, T6a
                                _MemGet m, o, T6b
                                _MemPut m, o1, T6b
                                _MemPut m, o, T6a
                                swapped = -1
                            End If
                            i = i + 1
                        Loop Until i + gap > EC
                    Loop Until gap = 1 And swapped = 0
                Case 7 'String
                    Dim T7a As String, T7b As String, T7c As String
                    T7a = Space$(ES): T7b = Space$(ES): T7c = Space$(ES)
                    gap = EC
                    Do
                        gap = Int(gap / 1.247330950103979)
                        If gap < 1 Then gap = 1
                        i = 0
                        swapped = 0
                        Do
                            o = m.OFFSET + i * ES
                            o1 = m.OFFSET + (i + gap) * ES
                            _MemGet m, o, T7a
                            _MemGet m, o1, T7b
                            If T7a > T7b Then
                                T7c = T7b
                                _MemPut m, o1, T7a
                                _MemPut m, o, T7c
                                swapped = -1
                            End If
                            i = i + 1
                        Loop Until i + gap > EC
                    Loop Until gap = 1 And swapped = false
                Case 8 '_INTEGER64
                    Dim T8a As _Integer64, T8b As _Integer64
                    gap = EC
                    Do
                        gap = 10 * gap \ 13
                        If gap < 1 Then gap = 1
                        i = 0
                        swapped = 0
                        Do
                            o = m.OFFSET + i * 8
                            o1 = m.OFFSET + (i + gap) * 8
                            If _MemGet(m, o, _Integer64) > _MemGet(m, o1, _Integer64) Then
                                _MemGet m, o1, T8a
                                _MemGet m, o, T8b
                                _MemPut m, o1, T8b
                                _MemPut m, o, T8a
                                swapped = -1
                            End If
                            i = i + 1
                        Loop Until i + gap > EC
                    Loop Until gap = 1 And swapped = 0
                Case 11: '_UNSIGNED _BYTE
                    Dim temp11(0 To 255) As _Unsigned Long
                    Dim t11 As _Unsigned _Byte
                    i = 0
                    Do
                        _MemGet m, m.OFFSET + i, t11
                        temp11(t11) = temp11(t11) + 1
                        i = i + 1
                    Loop Until i > EC
                    i1 = 0
                    Do
                        Do Until temp11(i1) = 0
                            _MemPut m, m.OFFSET + counter, i1 As _UNSIGNED _BYTE
                            counter = counter + 1
                            temp11(i1) = temp11(i1) - 1
                            If counter > EC Then Exit Sub
                        Loop
                        i1 = i1 + 1
                    Loop Until i1 > 255
                Case 12 '_UNSIGNED INTEGER
                    Dim temp12(0 To 65535) As _Unsigned Long
                    Dim t12 As _Unsigned Integer
                    i = 0
                    Do
                        _MemGet m, m.OFFSET + i * 2, t12
                        temp12(t12) = temp12(t12) + 1
                        i = i + 1
                    Loop Until i > EC
                    i1 = 0
                    Do
                        Do Until temp12(i1) = 0
                            _MemPut m, m.OFFSET + counter * 2, i1 As _UNSIGNED INTEGER
                            counter = counter + 1
                            temp12(i1) = temp12(i1) - 1
                            If counter > EC Then Exit Sub
                        Loop
                        i1 = i1 + 1
                    Loop Until i1 > 65535
                Case 14 '_UNSIGNED LONG
                    Dim T14a As _Unsigned Long, T14b As _Unsigned Long
                    gap = EC
                    Do
                        gap = 10 * gap \ 13
                        If gap < 1 Then gap = 1
                        i = 0
                        swapped = 0
                        Do
                            o = m.OFFSET + i * 4
                            o1 = m.OFFSET + (i + gap) * 4
                            If _MemGet(m, o, _Unsigned Long) > _MemGet(m, o1, _Unsigned Long) Then
                                _MemGet m, o1, T14a
                                _MemGet m, o, T14b
                                _MemPut m, o1, T14b
                                _MemPut m, o, T14a
                                swapped = -1
                            End If
                            i = i + 1
                        Loop Until i + gap > EC
                    Loop Until gap = 1 And swapped = 0
                Case 18: '_UNSIGNED _INTEGER64
                    Dim T18a As _Unsigned _Integer64, T18b As _Unsigned _Integer64
                    gap = EC
                    Do
                        gap = 10 * gap \ 13
                        If gap < 1 Then gap = 1
                        i = 0
                        swapped = 0
                        Do
                            o = m.OFFSET + i * 8
                            o1 = m.OFFSET + (i + gap) * 8
                            If _MemGet(m, o, _Unsigned _Integer64) > _MemGet(m, o1, _Unsigned _Integer64) Then
                                _MemGet m, o1, T18a
                                _MemGet m, o, T18b
                                _MemPut m, o1, T18b
                                _MemPut m, o, T18a
                                swapped = -1
                            End If
                            i = i + 1
                        Loop Until i + gap > EC
                    Loop Until gap = 1 And swapped = 0
            End Select
        End Sub
    $End If
$End If


$If INCLUDE_ALL = TRUE OR INCLUDE_SCREEN = TRUE OR INCLUDE_SCROLLUP = TRUE Then
    $If SCROLLUP_BM = UNDEFINED Then
        $Let SCROLLUP_BM = TRUE
        Sub ScrollUp (ImageHandle As Long)
            $Checking:Off
            Dim m As _MEM
            Dim As Long p, w
            Dim As String t
            m = _MemImage(ImageHandle)
            p = _PixelSize
            If p = 0 Then w = _Width * 2 Else w = _FontHeight * _Width * p
            t$ = Space$(m.SIZE - w)
            _MemGet m, m.OFFSET + w, t$
            Cls
            _MemPut m, m.OFFSET, t$
            _MemFree m
            $Checking:On
        End Sub
    $End If
$End If

$If INCLUDE_ALL = TRUE OR INCLUDE_SCREEN = TRUE OR INCLUDE_SCROLLDOWN = TRUE Then
    $If SCROLLDOWN_BM = UNDEFINED Then
        $Let SCROLLDOWN_BM = TRUE
        Sub ScrollDown (ImageHandle As Long)
            $Checking:Off
            Dim m As _MEM
            Dim As Long p, w
            Dim As String t
            m = _MemImage(ImageHandle)
            p = _PixelSize
            If p = 0 Then w = _Width * 2 Else w = _FontHeight * _Width * p
            t$ = Space$(m.SIZE - w)
            _MemGet m, m.OFFSET, t$
            Cls
            _MemPut m, m.OFFSET + w, t$
            _MemFree m
            $Checking:On
        End Sub
    $End If
$End If

$If INCLUDE_ALL = TRUE OR INCLUDE_SOUND = TRUE OR INCLUDE_SPEAK = TRUE Then
    $If SPEAK_BM = UNDEFINED Then
        $Let SPEAK_BM = TRUE
        $If WIN Then
            Sub Speak (text As String, Speaker As Integer, Speed As Long)
                Dim As String message, remove
                Dim out$
                Dim As Long j, i
                message = text
                'some symbols and such can't be used with Powershell like this, as they're command symbols
                'we need to strip them out of our text.  (Like apostrophes!)
                remove$ = "'" + Chr$(34) 'add to remove$ here, if more symbols need to be removed as future testing showcases problems
                For j = 1 To Len(remove$)
                    Do
                        i = InStr(message, Mid$(remove$, j, 1))
                        If i Then message = Left$(message, i - 1) + Mid$(message, i + 1)
                    Loop Until i = 0
                Next
                out$ = "Powershell -Command " + Chr$(34)
                out$ = out$ + "Add-Type -AssemblyName System.Speech; "
                out$ = out$ + "$Speech = New-Object System.Speech.Synthesis.SpeechSynthesizer; "
                If Speaker = 0 Then out$ = out$ + "$Speech.SelectVoice('Microsoft David Desktop'); "
                If Speaker = 1 Then out$ = out$ + "$Speech.SelectVoice('Microsoft Zira Desktop'); "
                If Speed Then out$ = out$ + "$Speech.Rate =" + Str$(Speed) + "; "
                out$ = out$ + "$Speech.Speak('" + message + "');" + Chr$(34)
                Shell _Hide out$
            End Sub
        $Else
                Sub Speak (dummy as string, dummy1 as Integer, dummy2 as long)
                BEEP
                _MESSAGEBOX "Warning!", "Notice: SUB Speak is a Windows-Only routine, as it relies upon Powershell to do its work.  This routine does not work on Linux or Mac.", "warning"
                End Sub
        $End If
    $End If
$End If

$If INCLUDE_ALL = TRUE OR INCLUDE_SCREEN = TRUE OR INCLUDE_BORDERWIDTH = TRUE Then
    $If BORDERWIDTH_BM = UNDEFINED Then
        $Let BORDERWIDTH_BM = TRUE
        Function BorderWidth&
            $Let GLUTGET = TRUE
            BorderWidth = glutGet(506)
        End Function
    $End If
$End If

$If INCLUDE_ALL = TRUE OR INCLUDE_SCREEN = TRUE OR INCLUDE_TITLEBARHEIGHT = TRUE Then
    $If TITLEBARHEIGHT_BM = UNDEFINED Then
        $Let TITLEBARHEIGHT_BM = TRUE
        Function TitleBarHeight&
            $Let GLUTGET = TRUE
            TitleBarHeight = glutGet(507)
        End Function
    $End If
$End If

$If INCLUDE_ALL = TRUE OR INCLUDE_SCREEN = TRUE OR INCLUDE_SCREENMOVE_MIDDLE = TRUE Then
    $If SCREENMOVE_MIDDLE_BM = UNDEFINED Then
        $Let SCREENMOVE_MIDDLE_BM = TRUE
        Sub ScreenMove_Middle
            'Moves to the absolute middle of the desktop, ignoring border and title, so the program window is centered without
            'taking them into consideration.
            $Let GLUTGET = TRUE
            _ScreenMove (_DesktopWidth - _Width - BorderWidth) / 2 + 1, (_DesktopHeight - _Height - BorderWidth) / 2 - TitleBarHeight + 1
        End Sub
    $End If
$End If

$If INCLUDE_ALL = TRUE OR INCLUDE_SCREEN = TRUE OR INCLUDE_SCREENMOVE = TRUE Then
    $If SCREENMOVE_BM = UNDEFINED Then
        $Let SCREENMOVE_BM = TRUE
        Sub ScreenMove (x, y)
            'Moves to the absolute coordinates of the desktop, ignoring border and title, so the program window is
            ' positioned with the program window at the desired position, without taking them into consideration.
            $Let GLUTGET = TRUE
            _ScreenMove x - BorderWidth, y - BorderWidth - TitleBarHeight
        End Sub
    $End If
$End If

$If INCLUDE_ALL = TRUE OR INCLUDE_SCREEN = TRUE OR INCLUDE_WINDOWWIDTH = TRUE Then
    $If WINDOWWIDTH_BM = UNDEFINED Then
        $Let WINDOWWIDTH_BM = TRUE
        Function WindowWidth
            WindowWidth = glutGet(102) '102 is the const value of GLUT_WINDOW_WIDTH
        End Function
    $End If
$End If

$If INCLUDE_ALL = TRUE OR INCLUDE_SCREEN = TRUE OR INCLUDE_WINDOWHEIGHT = TRUE Then
    $If WINDOWHEIGHT_BM = UNDEFINED Then
        $Let WINDOWHEIGHT_BM = TRUE
        Function WindowHeight
            WindowHeight = glutGet(103) '103 is the const value of GLUT_WINDOW_HEIGHT
        End Function
    $End If
$End If

$If INCLUDE_ALL = TRUE OR INCLUDE_MOUSE = TRUE OR INCLUDE_MOUSEBUTTONSTATUS = TRUE Then
    $If MOUSEBUTTONSTATUS_BM = UNDEFINED Then
        $Let MOUSEBUTTONSTATUS_BM = TRUE
        Function MouseButtonStatus% (takeMouseInput As Long)
            '1 -- left down
            '2 -- right down
            '4 -- middle down
            '8 -- left clicked
            '16 -- right clicked
            '32 -- middle clicked
            '64 -- left held
            '128 -- right held
            '256 -- middle held
            '512 -- scroll down
            '1024 -- scroll up

            Static StartTimer As _Float
            Static ButtonDown As Integer
            Const ClickLimit## = 0.2 'Less than 1/4th of a second to down, up a key to count as a CLICK.
            '                          Down longer counts as a HOLD event.
            Dim As Long tempMBS, bd
            If takeMouseInput Then
                While _MouseInput 'Remark out this block, if mouse main input/clear is going to be handled manually in main program.
                    Select Case Sgn(_MouseWheel)
                        Case 1: tempMBS = tempMBS Or 512
                        Case -1: tempMBS = tempMBS Or 1024
                    End Select
                Wend
            End If

            If _MouseButton(1) Then tempMBS = tempMBS Or 1
            If _MouseButton(2) Then tempMBS = tempMBS Or 2
            If _MouseButton(3) Then tempMBS = tempMBS Or 4

            If StartTimer = 0 Then
                If _MouseButton(1) Then 'If a button is pressed, start the timer to see what it does (click or hold)
                    ButtonDown = 1: StartTimer = Timer(0.01)
                    Mouse_StartX = _MouseX: Mouse_StartY = _MouseY
                ElseIf _MouseButton(2) Then
                    ButtonDown = 2: StartTimer = Timer(0.01)
                    Mouse_StartX = _MouseX: Mouse_StartY = _MouseY
                ElseIf _MouseButton(3) Then
                    ButtonDown = 3: StartTimer = Timer(0.01)
                    Mouse_StartX = _MouseX: Mouse_StartY = _MouseY
                End If
            Else
                bd = ButtonDown Mod 3
                If bd = 0 Then bd = 3
                If Timer(0.01) - StartTimer <= ClickLimit Then 'Button was down, then up, within time limit.  It's a click
                    If _MouseButton(bd) = 0 Then tempMBS = 4 * 2 ^ ButtonDown: ButtonDown = 0: StartTimer = 0
                Else
                    If _MouseButton(bd) = 0 Then 'hold event has now ended
                        tempMBS = 0: ButtonDown = 0: StartTimer = 0
                        Mouse_EndX = _MouseX: Mouse_EndY = _MouseY
                    Else 'We've now started the hold event
                        tempMBS = tempMBS Or 32 * 2 ^ ButtonDown
                    End If
                End If
            End If
            MouseButtonStatus = tempMBS
        End Function
    $End If
$End If

$If INCLUDE_ALL = TRUE OR INCLUDE_TIME = TRUE OR INCLUDE_GETDAY = TRUE Then
    $If GETDAY_BM = UNDEFINED Then
        $Let GETDAY_BM = TRUE
        Function GetDay$ (mm, dd, yyyy) 'use 4 digit year
            'From Zeller's congruence: https://en.wikipedia.org/wiki/Zeller%27s_congruence
            Dim As Long century, zerocentury, result
            Dim As String Day
            If mm < 3 Then mm = mm + 12: yyyy = yyyy - 1
            century = yyyy Mod 100
            zerocentury = yyyy \ 100
            result = (dd + Int(13 * (mm + 1) / 5) + century + Int(century / 4) + Int(zerocentury / 4) + 5 * zerocentury) Mod 7
            Select Case result
                Case 0: Day = "Saturday"
                Case 1: Day = "Sunday"
                Case 2: Day = "Monday"
                Case 3: Day = "Tuesday"
                Case 4: Day = "Wednesday"
                Case 5: Day = "Thursday"
                Case 6: Day = "Friday"
            End Select
            GetDay$ = Day
        End Function
    $End If
$End If

$If INCLUDE_ALL = TRUE OR INCLUDE_TIME = TRUE OR INCLUDE_TIMESTAMP = TRUE Then
    $If TIMESTAMP_BM = UNDEFINED Then
        $Let TIMESTAMP_BM = TRUE
        Function TimeStamp## (d$, t##) 'date and timer
            'Based on Unix Epoch time, which starts at year 1970.
            Dim l As _Integer64, l1 As _Integer64, m As _Integer64
            Dim d As _Integer64, y As _Integer64, i As _Integer64
            Dim s As _Float

            l = InStr(d$, "-")
            l1 = InStr(l + 1, d$, "-")
            m = Val(Left$(d$, l))
            d = Val(Mid$(d$, l + 1))
            y = Val(Mid$(d$, l1 + 1))
            If y < 1970 Then 'calculate shit backwards
                Select Case m 'turn the day backwards for the month
                    Case 1, 3, 5, 7, 8, 10, 12: d = 31 - d '31 days
                    Case 2: d = 28 - d 'special 28 or 29.
                    Case 4, 6, 9, 11: d = 30 - d '30 days
                End Select
                If y Mod 4 = 0 And m < 3 Then 'check for normal leap year, and we're before it...
                    d = d + 1 'assume we had a leap year, subtract another day
                    If y Mod 100 = 0 And y Mod 400 <> 0 Then d = d - 1 'not a leap year if year is divisible by 100 and not 400
                End If

                'then count the months that passed after the current month
                For i = m + 1 To 12
                    Select Case i
                        Case 2: d = d + 28
                        Case 3, 5, 7, 8, 10, 12: d = d + 31
                        Case 4, 6, 9, 11: d = d + 30
                    End Select
                Next

                'we should now have the entered year calculated.  Now lets add in for each year from this point to 1970
                d = d + 365 * (1969 - y) '365 days per each standard year
                For i = 1968 To y + 1 Step -4 'from 1968 onwards,backwards, skipping the current year (which we handled previously in the FOR loop)
                    d = d + 1 'subtract an extra day every leap year
                    If (i Mod 100) = 0 And (i Mod 400) <> 0 Then d = d - 1 'but skipping every year divisible by 100, but not 400
                Next
                s## = d * 24 * 60 * 60 'Seconds are days * 24 hours * 60 minutes * 60 seconds
                TimeStamp## = -(s## + 24 * 60 * 60 - t##)
                Exit Function
            Else
                y = y - 1970
            End If

            For i = 1 To m 'for this year,
                Select Case i 'Add the number of days for each previous month passed
                    Case 1: d = d 'January doestn't have any carry over days.
                    Case 2, 4, 6, 8, 9, 11: d = d + 31
                    Case 3 'Feb might be a leap year
                        If (y Mod 4) = 2 Then 'if this year is divisible by 4 (starting in 1972)
                            d = d + 29 'its a leap year
                            If (y Mod 100) = 30 And (y Mod 400) <> 30 Then 'unless..
                                d = d - 1 'the year is divisible by 100, and not divisible by 400
                            End If
                        Else 'year not divisible by 4, no worries
                            d = d + 28
                        End If
                    Case 5, 7, 10, 12: d = d + 30
                End Select
            Next
            d = (d - 1) + 365 * y 'current month days passed + 365 days per each standard year
            For i = 2 To y - 1 Step 4 'from 1972 onwards, skipping the current year (which we handled previously in the FOR loopp)
                d = d + 1 'add an extra day every leap year
                If (i Mod 100) = 30 And (i Mod 400) <> 30 Then d = d - 1 'but skiping every year divisible by 100, but not 400
            Next
            s## = d * 24 * 60 * 60 'Seconds are days * 24 hours * 60 minutes * 60 seconds
            TimeStamp## = (s## + t##)
        End Function
    $End If
$End If

$If INCLUDE_ALL = TRUE OR INCLUDE_TIME = TRUE OR INCLUDE_EXTENDEDTIMER = TRUE Then
    $If EXTENDEDTIMER_BM = UNDEFINED Then
        $Let EXTENDEDTIMER_BM = TRUE
        Function ExtendedTimer##
            'Simplified version of the TimeStamp routine, streamlined to only give positive values based on the current timer.
            'Note:  Only good until the year 2100, as we don't do all the fancy calculations for leap years.
            'A timer should work quickly and efficiently in the background; and the less we do, the less lag we might insert
            'into a program.

            Dim m As Integer, d As Integer, y As Integer
            Dim s As _Float, day As String
            day = Date$
            m = Val(Left$(day, 2))
            d = Val(Mid$(day, 4, 2))
            y = Val(Right$(day, 4)) - 1970
            Select Case m 'Add the number of days for each previous month passed
                Case 2: d = d + 31
                Case 3: d = d + 59
                Case 4: d = d + 90
                Case 5: d = d + 120
                Case 6: d = d + 151
                Case 7: d = d + 181
                Case 8: d = d + 212
                Case 9: d = d + 243
                Case 10: d = d + 273
                Case 11: d = d + 304
                Case 12: d = d + 334
            End Select
            If (y Mod 4) = 2 And m > 2 Then d = d + 1 'add a day if this is leap year and we're past february
            d = (d - 1) + 365 * y 'current month days passed + 365 days per each standard year
            d = d + (y + 2) \ 4 'add in days for leap years passed
            s = d * 24 * 60 * 60 'Seconds are days * 24 hours * 60 minutes * 60 seconds
            ExtendedTimer## = (s + Timer)
        End Function
    $End If
$End If





'DECLARED LIBRARY Code which is added as needed automatically from the routines above.
$If INCLUDE_ALL = TRUE OR GLUTGET = TRUE OR INCLUDE_GLUTGET = TRUE Then
    $If GLUTGET_DECLARED = UNDEFINED Then
        $Let GLUTGET_DECLARED = TRUE
        Declare Library
            Function glutGet& (ByVal what&)
        End Declare
    $End If
$End If

$If INCLUDE_ALL = TRUE OR GLUTRESHAPEWINDOW = TRUE OR INCLUDE_GLUTRESHAPEWINDOW = TRUE Then
    $If GLUTRESHAPEWINDOW_DECLARED = UNDEFINED Then
        $Let GLUTRESHAPEWINDOW_DECLARED = TRUE
        Declare Library
            Sub glutReshapeWindow (ByVal width&, Byval height&)
        End Declare
    $End If
$End If



